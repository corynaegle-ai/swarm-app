/**
 * WebSocket Server for Swarm Platform
 * Real-time updates for HITL sessions, approvals, and build progress
 * 
 * Created: 2025-12-14
 * Updated: 2025-12-17 - Migrated to PostgreSQL
 */

const { WebSocketServer } = require('ws');
const jwt = require('jsonwebtoken');
const { queryOne } = require('./db');

const JWT_SECRET = process.env.JWT_SECRET || 'dev-secret-change-in-production';

// Store active connections by room
const rooms = new Map(); // Map<roomId, Set<ws>>
const clientRooms = new Map(); // Map<ws, Set<roomId>>

/**
 * Initialize WebSocket server on existing HTTP server
 */
function initWebSocket(server) {
  const wss = new WebSocketServer({ 
    server,
    path: '/ws'
  });

  wss.on('connection', (ws, req) => {
    console.log('[WS] New connection attempt');
    
    // Parse auth token from query string
    const url = new URL(req.url, 'http://localhost');
    const token = url.searchParams.get('token');

    if (!token) {
      console.log('[WS] No token provided, closing');
      ws.close(4001, 'Authentication required');
      return;
    }

    // Verify JWT
    let user;
    try {
      user = jwt.verify(token, JWT_SECRET);
      ws.user = user;
      ws.tenantId = user.tenantId;
      console.log(`[WS] Authenticated: ${user.email} (tenant: ${user.tenantId})`);
    } catch (err) {
      console.log('[WS] Invalid token:', err.message);
      ws.close(4002, 'Invalid token');
      return;
    }

    // Initialize client's room set
    clientRooms.set(ws, new Set());

    // Send welcome message
    ws.send(JSON.stringify({
      type: 'connected',
      userId: user.id,
      timestamp: new Date().toISOString()
    }));

    // Handle incoming messages
    ws.on('message', (data) => {
      try {
        const msg = JSON.parse(data.toString());
        handleMessage(ws, msg);
      } catch (err) {
        console.error('[WS] Invalid message:', err.message);
        ws.send(JSON.stringify({ type: 'error', message: 'Invalid JSON' }));
      }
    });

    // Handle disconnect
    ws.on('close', () => {
      console.log(`[WS] Client disconnected: ${user?.email}`);
      cleanupClient(ws);
    });

    ws.on('error', (err) => {
      console.error('[WS] Client error:', err.message);
      cleanupClient(ws);
    });
  });

  console.log('[WS] WebSocket server initialized on /ws');
  return wss;
}

/**
 * Handle incoming WebSocket messages
 */
function handleMessage(ws, msg) {
  const { type, room, sessionId } = msg;

  switch (type) {
    case 'subscribe':
      // Subscribe to a room (e.g., session:abc123)
      if (room) {
        subscribe(ws, room);
      } else if (sessionId) {
        // Convenience: subscribe to session by ID
        subscribeToSession(ws, sessionId);
      }
      break;

    case 'unsubscribe':
      if (room) {
        unsubscribe(ws, room);
      }
      break;

    case 'ping':
      ws.send(JSON.stringify({ type: 'pong', timestamp: Date.now() }));
      break;

    default:
      console.log(`[WS] Unknown message type: ${type}`);
  }
}


/**
 * Subscribe client to a room with tenant isolation
 */
async function subscribe(ws, roomId) {
  // Validate tenant access for session rooms
  if (roomId.startsWith('session:')) {
    const sessionId = roomId.replace('session:', '');
    const hasAccess = await canAccessSession(ws.tenantId, sessionId);
    if (!hasAccess) {
      ws.send(JSON.stringify({ 
        type: 'error', 
        message: 'Access denied to session' 
      }));
      return;
    }
  }

  // Add to room
  if (!rooms.has(roomId)) {
    rooms.set(roomId, new Set());
  }
  rooms.get(roomId).add(ws);
  clientRooms.get(ws).add(roomId);

  ws.send(JSON.stringify({ 
    type: 'subscribed', 
    room: roomId,
    timestamp: Date.now()
  }));
  
  console.log(`[WS] ${ws.user?.email} subscribed to ${roomId}`);
}

/**
 * Subscribe to session with automatic room naming
 */
function subscribeToSession(ws, sessionId) {
  subscribe(ws, `session:${sessionId}`);
}

/**
 * Unsubscribe client from a room
 */
function unsubscribe(ws, roomId) {
  if (rooms.has(roomId)) {
    rooms.get(roomId).delete(ws);
    if (rooms.get(roomId).size === 0) {
      rooms.delete(roomId);
    }
  }
  clientRooms.get(ws)?.delete(roomId);

  ws.send(JSON.stringify({ type: 'unsubscribed', room: roomId }));
  console.log(`[WS] ${ws.user?.email} unsubscribed from ${roomId}`);
}

/**
 * Clean up when client disconnects
 */
function cleanupClient(ws) {
  const clientRoomSet = clientRooms.get(ws);
  if (clientRoomSet) {
    for (const roomId of clientRoomSet) {
      if (rooms.has(roomId)) {
        rooms.get(roomId).delete(ws);
        if (rooms.get(roomId).size === 0) {
          rooms.delete(roomId);
        }
      }
    }
  }
  clientRooms.delete(ws);
}

/**
 * Check if tenant can access session (async PostgreSQL)
 */
async function canAccessSession(tenantId, sessionId) {
  try {
    const session = await queryOne(
      'SELECT tenant_id FROM hitl_sessions WHERE id = $1',
      [sessionId]
    );
    
    return session && session.tenant_id === tenantId;
  } catch (err) {
    console.error('[WS] Session access check failed:', err.message);
    return false;
  }
}


// ============================================
// Broadcast Functions (exported for use in routes)
// ============================================

const broadcast = {
  /**
   * Send to all clients in a room
   */
  toRoom(roomId, eventType, payload) {
    const roomClients = rooms.get(roomId);
    if (!roomClients || roomClients.size === 0) return 0;

    const message = JSON.stringify({
      type: eventType,
      ...payload,
      timestamp: Date.now()
    });

    let sent = 0;
    for (const client of roomClients) {
      if (client.readyState === 1) { // WebSocket.OPEN
        client.send(message);
        sent++;
      }
    }
    
    console.log(`[WS] Broadcast ${eventType} to ${roomId}: ${sent} clients`);
    return sent;
  },

  /**
   * Send to all clients subscribed to a session
   */
  toSession(sessionId, eventType, payload) {
    return this.toRoom(`session:${sessionId}`, eventType, {
      sessionId,
      ...payload
    });
  },


  /**
   * Send to all clients of a tenant
   */
  toTenant(tenantId, eventType, payload) {
    return this.toRoom(`tenant:${tenantId}`, eventType, {
      tenantId,
      ...payload
    });
  },

  /**
   * Send session state update
   */
  sessionUpdate(sessionId, state, progress, extra = {}) {
    return this.toSession(sessionId, 'session:update', {
      state,
      progress,
      ...extra
    });
  },

  /**
   * Send new message notification
   */
  sessionMessage(sessionId, message) {
    return this.toSession(sessionId, 'session:message', { message });
  },

  /**
   * Send approval request notification
   */
  approvalRequested(sessionId, data) {
    return this.toSession(sessionId, 'approval:requested', {
      approvalId: data.approvalId,
      action: data.action,
      context: data.context || {}
    });
  },


  /**
   * Send approval resolution
   */
  approvalResolved(sessionId, approvalId, status, resolvedBy) {
    return this.toSession(sessionId, 'approval:resolved', {
      approvalId,
      status,
      resolvedBy
    });
  },

  /**
   * Send build progress update
   */
  buildProgress(sessionId, percent, currentTask, details = {}) {
    return this.toSession(sessionId, 'build:progress', {
      percent,
      currentTask,
      ...details
    });
  },

  /**
   * Send spec generated notification
   */
  specGenerated(sessionId, data) {
    return this.toSession(sessionId, 'spec:generated', {
      spec: data.spec,
      confidence: data.confidence
    });
  },

  /**
   * Send tickets generated notification
   */
  ticketsGenerated(sessionId, data) {
    return this.toSession(sessionId, 'tickets:generated', {
      tickets: data.tickets,
      count: data.tickets?.length || 0
    });
  }
};

/**
 * Get connection stats
 */
function getStats() {
  return {
    totalRooms: rooms.size,
    totalClients: clientRooms.size,
    rooms: Array.from(rooms.entries()).map(([id, clients]) => ({
      id,
      clients: clients.size
    }))
  };
}

module.exports = {
  initWebSocket,
  broadcast,
  getStats
};
