#!/usr/bin/env python3
"""Add GAP #3 methods to engine.js"""

# Read the file
with open('/opt/swarm/engine/lib/engine.js', 'r') as f:
    content = f.read()

# New methods to add
new_methods = '''
    /**
     * GAP #3: Post-code generation verification and PR creation
     * Called after agent successfully generates code
     */
    async _postCodeGeneration(ticketId, branchName, repoUrl, ticket, result, attempt = 1) {
        log('INFO', `Starting verification for ${ticketId} (attempt ${attempt}/${MAX_ATTEMPTS})`);
        
        // Update to verifying state
        this.stmts.setVerifying.run(ticketId);
        
        // Update branch name if not set
        if (!ticket.branch_name) {
            this.stmts.updateBranch.run(branchName, ticketId);
        }
        
        try {
            // Call verifier service
            const verifyResult = await verify({
                ticketId,
                branchName,
                repoUrl,
                attempt,
                acceptanceCriteria: ticket.acceptance_criteria,
                phases: ['static', 'automated', 'sentinel']
            });
            
            log('INFO', `Verification result for ${ticketId}: ${verifyResult.status}`);
            
            if (verifyResult.status === 'passed' || verifyResult.ready_for_pr) {
                // Verification passed - create PR
                const prUrl = await this._createPR(ticketId, branchName, repoUrl, ticket);
                const evidence = JSON.stringify(verifyResult);
                this.stmts.setInReview.run(prUrl, evidence, ticketId);
                log('INFO', `PR created for ${ticketId}: ${prUrl}`);
                
            } else if (attempt < MAX_ATTEMPTS) {
                // Verification failed but can retry
                log('WARN', `Verification failed for ${ticketId}, marking for review (retry not yet impl)`);
                const feedback = formatFeedbackForRetry(verifyResult.feedback_for_agent);
                
                // Store feedback for agent context on retry
                this.stmts.storeArtifact.run(
                    randomUUID(), 
                    ticketId, 
                    `verification_feedback_attempt_${attempt}`, 
                    feedback
                );
                
                // Mark as needs_review (retry mechanism TODO)
                const evidence = JSON.stringify(verifyResult);
                this.stmts.setNeedsReview.run(evidence, ticketId);
                
            } else {
                // Max retries exceeded
                log('ERROR', `Max verification attempts exceeded for ${ticketId}`);
                const evidence = JSON.stringify(verifyResult);
                this.stmts.setNeedsReview.run(evidence, ticketId);
            }
            
        } catch (e) {
            log('ERROR', `Verification error for ${ticketId}: ${e.message}`);
            // On verification error, complete normally but log
            const outputJson = JSON.stringify(result || {});
            this.stmts.completeTicket.run(outputJson, ticketId);
        }
    }
    
    /**
     * Create PR using GitHub CLI
     */
    async _createPR(ticketId, branchName, repoUrl, ticket) {
        try {
            // Parse repo owner/name from URL
            const match = repoUrl.match(/github\\.com[\\/:]([^\\/]+)\\/([^\\/\\.]+)/);
            if (!match) {
                throw new Error(`Cannot parse repo URL: ${repoUrl}`);
            }
            const [, owner, repo] = match;
            
            // Use GitHub CLI to create PR
            const title = `feat(${ticketId}): ${ticket.title || 'Automated changes'}`;
            const body = `## Automated PR from Swarm\\n\\n**Ticket**: ${ticketId}\\n**Description**: ${ticket.description || 'No description'}\\n\\n### Acceptance Criteria\\n${ticket.acceptance_criteria || 'None specified'}\\n\\n---\\n*Generated by Swarm Engine*`;

            const ghToken = readFileSync('/root/.github_token', 'utf8').trim();
            
            const cmd = `gh pr create --repo ${owner}/${repo} --title "${title.replace(/"/g, '\\\\"')}" --body "${body.replace(/"/g, '\\\\"')}" --base main --head ${branchName}`;
            
            const prResult = execSync(cmd, {
                env: { ...process.env, GH_TOKEN: ghToken },
                encoding: 'utf8',
                timeout: 30000
            }).trim();
            
            return prResult; // Returns PR URL
            
        } catch (e) {
            log('ERROR', `Failed to create PR for ${ticketId}: ${e.message}`);
            // Return placeholder URL on error
            return `https://github.com/error-creating-pr/${ticketId}`;
        }
    }
'''

# Find the insertion point - after _releaseExecution, before getStatus
marker = '''    }
    
    /**
     * Get engine status
     */
    getStatus() {'''

if marker in content:
    # Insert before getStatus
    insertion_point = content.find(marker)
    # Find the closing brace of _releaseExecution
    brace_pos = content.rfind('    }\n', 0, insertion_point)
    if brace_pos > 0:
        content = content[:brace_pos+6] + new_methods + content[brace_pos+6:]
        print("SUCCESS: Inserted _postCodeGeneration and _createPR methods")
    else:
        print("ERROR: Could not find proper insertion point")
        exit(1)
else:
    print("ERROR: Could not find getStatus marker")
    exit(1)

# Write back
with open('/opt/swarm/engine/lib/engine.js', 'w') as f:
    f.write(content)

print("File updated successfully")
