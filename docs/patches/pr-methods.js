    /**
     * Create PR using GitHub REST API
     */
    async _createPR(ticketId, branchName, repoUrl, ticket) {
        try {
            const match = repoUrl.match(/github\.com[\/:]([^\/]+)\/([^\/\.]+)/);
            if (!match) {
                throw new Error(`Cannot parse repo URL: ${repoUrl}`);
            }
            const [, owner, repo] = match;
            const repoName = repo.replace(/\.git$/, '');
            
            let ghToken;
            try {
                ghToken = readFileSync('/root/.github_token', 'utf8').trim();
            } catch (e) {
                throw new Error('GitHub token not found at /root/.github_token');
            }
            
            const title = `feat(${ticketId}): ${ticket.title || 'Automated changes'}`;
            const body = this._buildPRBody(ticketId, ticket);
            
            const response = await fetch(`https://api.github.com/repos/${owner}/${repoName}/pulls`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${ghToken}`,
                    'Accept': 'application/vnd.github+json',
                    'X-GitHub-Api-Version': '2022-11-28',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    title,
                    body,
                    head: branchName,
                    base: 'main'
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                if (response.status === 422) {
                    if (error.errors?.some(e => e.message?.includes('already exists'))) {
                        const existingPR = await this._findExistingPR(owner, repoName, branchName, ghToken);
                        if (existingPR) {
                            log('INFO', `PR already exists for ${branchName}: ${existingPR}`);
                            return existingPR;
                        }
                    }
                    if (error.errors?.some(e => e.message?.includes('No commits'))) {
                        throw new Error(`No commits between main and ${branchName}`);
                    }
                }
                throw new Error(`GitHub API error (${response.status}): ${error.message || JSON.stringify(error)}`);
            }
            
            const pr = await response.json();
            log('INFO', `PR created: ${pr.html_url}`);
            await this._addPRLabels(owner, repoName, pr.number, ghToken, ticket);
            return pr.html_url;
            
        } catch (e) {
            log('ERROR', `Failed to create PR for ${ticketId}: ${e.message}`);
            throw e;
        }
    }
    
    _buildPRBody(ticketId, ticket) {
        let body = `## Automated PR from Swarm\n\n**Ticket**: \`${ticketId}\`\n\n`;
        if (ticket.description) {
            body += `### Description\n${ticket.description}\n\n`;
        }
        if (ticket.acceptance_criteria) {
            body += `### Acceptance Criteria\n`;
            try {
                const criteria = typeof ticket.acceptance_criteria === 'string' 
                    ? JSON.parse(ticket.acceptance_criteria) : ticket.acceptance_criteria;
                if (Array.isArray(criteria)) {
                    criteria.forEach(c => body += `- [ ] ${c}\n`);
                } else {
                    body += `${ticket.acceptance_criteria}\n`;
                }
            } catch {
                body += `${ticket.acceptance_criteria}\n`;
            }
            body += '\n';
        }
        body += `---\n*Generated by Swarm Engine*`;
        return body;
    }
    
    async _findExistingPR(owner, repo, branchName, token) {
        try {
            const response = await fetch(
                `https://api.github.com/repos/${owner}/${repo}/pulls?head=${owner}:${branchName}&state=open`,
                {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Accept': 'application/vnd.github+json',
                        'X-GitHub-Api-Version': '2022-11-28'
                    }
                }
            );
            if (response.ok) {
                const prs = await response.json();
                if (prs.length > 0) return prs[0].html_url;
            }
            return null;
        } catch {
            return null;
        }
    }
    
    async _addPRLabels(owner, repo, prNumber, token, ticket) {
        try {
            const labels = ['swarm-generated'];
            if (ticket.estimated_scope) labels.push(`scope:${ticket.estimated_scope}`);
            await fetch(`https://api.github.com/repos/${owner}/${repo}/issues/${prNumber}/labels`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Accept': 'application/vnd.github+json',
                    'X-GitHub-Api-Version': '2022-11-28',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ labels })
            });
        } catch (e) {
            log('DEBUG', `Could not add labels to PR: ${e.message}`);
        }
    }

